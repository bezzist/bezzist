from django.contrib.auth.models import User
from django.core.exceptions import PermissionDenied
from django.db import models
from django.db.models import Q


class AbstractTimeStampedModel(models.Model):

    '''
    Abstract model class that keeps track of created and modified times.
    Created and modified are automatically kept track on every save.
    '''

    class Meta:
        abstract = True

    created = models.DateTimeField(auto_now_add=True)
    modified = models.DateTimeField(auto_now=True)

    def _get_name(self):
        return self.__class__.__name__.lower()


class AbstractUserCreatedModel(AbstractTimeStampedModel):

    '''
    Abstract model class that inherits from AbstractTimeStampedModel
    and must have a user.
    '''

    deleted = models.BooleanField(default=False)
    flags = models.IntegerField(default=0)
    flagged = models.BooleanField(default=False)
    user = models.ForeignKey(User, null=True)  # while all posting is allowed

    class Meta:
        abstract = True

    def increment_flags(self):
        self.flags += 1
        self.save()

    def soft_delete(self):
        self.deleted = True
        self.save()

    def is_owner(self, user):
        if self.user == user:
            return True
        return False


class BrowserIdentifier(models.Model):
    '''
    Stores the semi-unique browser id generated by Valve's Fingerprint library
    (https://github.com/Valve/fingerprintjs) and the IP from which the request
    was sent.
    '''

    browser_id = models.CharField(max_length=30)
    ip_address = models.CharField(max_length=45)

    def equals(self, browser_id, ip_address):
        return self.browser_id == browser_id and self.ip_address == ip_address


class AbstractUserScoredModel(AbstractUserCreatedModel):

    '''
    Abstract model class that inherits from AbstractUserCreatedModel
    and keeps track of model score.
    '''

    score = models.IntegerField(default=0)
    liked = models.ManyToManyField(User, blank=True, related_name='%(class)s_liked_users')
    liked_browsers = models.ManyToManyField('BrowserIdentifier', blank=True, related_name='%(class)s_browser_liked_users')
    disliked = models.ManyToManyField(User, blank=True, related_name='%(class)s_disliked_users')

    class Meta:
        abstract = True

    def increment_score(self, request):
        '''
        Increments score of a scored model.

        This method is callable without user authentication, and is
        thus prone to abuse. To make it difficult for a user to abuse
        the voting system, there are three things that we do, in case
        the voting user is not authenticated:

        LocalStorage: We store all voted items in the browser's LocalStorage
        and forbid calling this method if user has already voted for the item.

        Cookies and Session: We store voted-for items in session-based cookies
        and prevent users from voting if the item they are voting for is
        in the cookie.

        Browser fingerprinting: We store, in the DB, a hash of the IP
        and a browser fingerprint generated in the frontend (see
        https://github.com/Valve/fingerprintjs) and check against that to see if a
        user has voted for an item.
        '''
        if request.user.is_authenticated():
            if request.user.userprofile.superuser:
                request.user.userprofile.increment_score(1)
            elif request.user in self.liked.all():
                raise PermissionDenied()
            else:
                self.liked.add(request.user)
                request.user.userprofile.increment_score(1)
                if (self.user != request.user):
                    self.user.userprofile.increment_score(1)
        else:
            if self._anonymous_user_voted(request):
                raise PermissionDenied()
            else:
                self._process_anonymous_user_vote(request)
        return self._modify_score(self.score+1)

    def decrement_score(self, request):
        if request.user.is_authenticated():
            if request.user in self.liked.all():
                self.liked.remove(request.user)
                request.user.userprofile.decrement_score(1)
                if (self.user != request.user):
                    self.user.userprofile.decrement_score(1)
            else:
                raise PermissionDenied()
        else:
            if not self._anonymous_user_voted(request):
                raise PermissionDenied()
            else:
                self._process_anonymous_user_unvote(request)
        return self._modify_score(self.score-1)

    def _modify_score(self, score):
        self.score = score
        self.save()
        return self.score

    def _anonymous_user_voted(self, request):
        # Check session cookie
        try:
            if self.id in request.session.get(self._get_vote_session_key()):
                return True
        except:
            request.session[self._get_vote_session_key()] = {}  # using dictionary instead of set for JSON serializability
        # Check browser
        if self._get_or_create_browser_identifier(request) in self.liked_browsers.all():
            return True
        else:
            return False

    def _process_anonymous_user_vote(self, request):
        # Add to session cookie
        request.session[self._get_vote_session_key()][self.id] = self.id
        request.session.modified = True
        self.liked_browsers.add(self._get_or_create_browser_identifier(request))

    def _process_anonymous_user_unvote(self, request):
        try:
            request.session[self._get_vote_session_key()].pop(str(self.id))
            request.session.modified = True
        except:
            # if it doesn't exist in the session, that's fine.
            pass
        self.liked_browsers.remove(self._get_or_create_browser_identifier(request))

    def _get_or_create_browser_identifier(self, request):
        try:
            browser_identifier = BrowserIdentifier.objects.get(
                Q(browser_id=request.POST.get('bId')),
                Q(ip_address=self._get_ip_address(request)))
        except:
            browser_identifier = BrowserIdentifier.objects.create(
                browser_id=request.POST.get('bId'),
                ip_address=self._get_ip_address(request))
        return browser_identifier

    def _get_ip_address(self, request):
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip

    def _get_vote_session_key(self):
        return 'voted_{}'.format(self._get_name())


class MappableModel(object):

    '''
    Provide methods to shallow/deep mappify a Django model.

    In shallow mappification, relation fields (many-to-many and foreignkey)
    return id's of the related object, if it exists.

    In deep mappification, relation fields are recursively
    traveled (1-level) to return a JSON representation of the related object.

    FileField and ImageField returns the url.

    '''

    def deep_mappify(self, exception_fields=[]):
        return self._mappify(deep_copy=True, exception_fields=exception_fields)

    def shallow_mappify(self, exception_fields=[]):
        return self._mappify(deep_copy=False, exception_fields=exception_fields)

    def _mappify(self, deep_copy=False, exception_fields=[]):
        model = {}
        for field in self._meta.fields:
            if field.name in exception_fields:
                pass
            elif isinstance(field, models.FileField) or isinstance(field, models.ImageField):
                try:
                    model[field.name] = getattr(self, field.name).url
                except:
                    model[field.name] = ''
            elif isinstance(field, models.ForeignKey):
                if deep_copy:
                    model[field.name] = self._mappify(getattr(self, field.name))
                else:
                    try:
                        model[field.name] = getattr(self, field.name).id
                    except:
                        model[field.name] = ''
            elif isinstance(field, models.ManyToManyField):
                print field.name
                if deep_copy:
                    model[field.name] = self._mappify(getattr(self, field.name))
                else:
                    try:
                        model[field.name] = map(lambda o: o.id, list(getattr(self, field.name).all()))
                    except:
                        model[field.name] = []
            else:
                model[field.name] = getattr(self, field.name)

        return model
